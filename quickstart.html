<!DOCTYPE html>
<html>
<head>
	<title>Paracel in Twenty Minutes</title>
</head>
<body onload="prettyPrint()">
	<div class="title1">
		<h2><font size="6" color="#990012">Introduction</font></h2>
		<p><font size="4" color="#3D3C3A">
		This is a quick tutorial that should take no more than 20 minutes to complete.<br>
		Before everything is going on, please make sure that you already have <b>paracel</b> installed successfully.
		</font></p>
	</div>
	<div class="title2">
		<h2><font size="6" color="#990012">Programming</font></h2>
		<p><font size="4" color="#3D3C3A">
		<b>Paracel</b> offer a distributed, global key-value space which is called parameter server. Messages in <b>paracel</b> are also defined as parameters which have a key-value structure. When doing commnication, you need to talk to servers by <b>read/write/update</b> the messages.
		</font></p>
	</div>
	<div class="title3">
		<h2><font size="6" color="#990012">Word Count Example</font></h2>
		<p>
		<div><font size="4" color="#3D3C3A">
		&nbsp;&nbsp;&nbsp;
		Let's start with a simple word count example with <b>paracel</b>.<br><br>
		&nbsp;&nbsp;&nbsp;
		Firstly, you must write a subclass which inherits the <b>paralg</b> baseclass:
		</font>
<pre class="prettyprint">
// wc.hpp
#include "ps.hpp" // paralg
class word_count : public paralg {
public:
  word_count(paracel::Comm comm, string hosts_dct_str, 
  string in, string out, int topk) : 
  paralg(hosts_dct_str, comm, out, 1),
  input(in),
  output(out) {
    // init local member var here...
  }
private:
  string input, output;
  int ktop;
};
</pre>		
			</div>
			<div><font size="4" color="#3D3C3A">
			&nbsp;&nbsp;&nbsp;
			Secondly, write a update function which will be called by parameter servers(something like a reduce function):
			</font>
<pre class="prettyprint">
// update.cpp
#include "proxy.hpp" // update_proxy
#include "paracel_types.hpp" // update_result

int local_reduce(int value, int delta) {
  return a + b;
}

update_result updater = update_proxy(local_reduce) // register updater to paracel framework
</pre>
			</div>
			<div><font size="4" color="#3D3C3A">
			&nbsp;&nbsp;&nbsp;
			Thirdly, implement the virtual method 'solve' to work out the problem, for example:
			</font>
<pre class="prettyprint">
// wc.hpp
private:
  void local_learning(const vector<string> & lines) {
    paracel_register_bupdate("update.so", "updater"); // register update function in the subclass
    for(auto & line : lines) {
      auto word_lst = local_parser(line); // parse line to a word list
      for(auto & word : word_lst) {
        paracel_update_default(word, 1); // something like `setdefault in Python`
      }
    }
    sync(); // wait finish of every workers
    auto result = paracel_read_topk(ktop); // get ktop
    // dump result into output
  }

public:
  virtual void solve() {
    auto lines = paracel_load(input); // parallel load input to lines
    local_learning(lines);
  }
</pre>
			</div>
			<div><font size="4" color="#3D3C3A">
			&nbsp;&nbsp;&nbsp;
			Lastly, you need to create a driver to run your algorithm:
			</font>
<pre class="prettyprint">
// main.cpp
#include <google/gflags.h>
#include "utils.hpp"
#include "wc.hpp"
DEFINE_string(server_info);
DEFINE_string(cfg_file);
int main(int argc, char *argv[])
{
  // init worker environment
  paracel::main_env comm_main_env(argc, argv);
  paracel::Comm comm(MPI_COMM_WORLD);

  // init parameter server environment
  google::SetUsageMessage("[options]\n\t--server_info\n");
  google::ParseCommandLineFlags(&argcm &argv, true);
  
  // you can also init local paras by other fmt(we recomment json)
  string input = "wc.hpp"; 
  string output = "result.txt";
  int ktop = 10;
  
  // create a instance
  word_count solver(comm, FLAGS_server_info, input, output, ktop);
  // solve problems
  solver.solve();
  return 0;
}
</pre>
			</div>
			<div><font size="4" color="#3D3C3A">
			&nbsp;&nbsp;&nbsp;		
			Yes, you are almost done!<br>
			&nbsp;&nbsp;&nbsp;
			The remaining thing you need to do is compiling your code, and run with <b>prun.py</b>.
			</font>
			</div>
		</p>
	</div>
	<div class="title4">
	<h2><font size="6" color="#990012">Second Version of Word Count</font></h2>
		<p><font size="4" color="#3D3C3A">
		&nbsp;&nbsp;&nbsp;		
		In the former word count example above, we use <b>paracel_update_default</b> which is a little expensive. The reason of that is <b>paracel_update_default</b> will ask servers if a specified key is already existed. If it is, do update with user-defined updater. If it isn't, init the key with your value. So we can avoid this "asking" by using <b>is_caced</b> function. Now the code looks like this:
		</font></p>
<pre class="prettyprint">
// wc.hpp
private:
  void local_learning(const vector<string> & lines) {
    paracel_register_bupdate("update.so", "updater"); // register update function in the subclass
    for(auto & line : lines) {
      auto word_lst = local_parser(line); // parse line to a word list
      for(auto & word : word_lst) {
        if(is_cached(word)) {
          paracel_bupdate(word, 1); // block-update interface
        } else {
          paracel_update_default(word, 1);
        } // end of if
      } // word
    } // line
    ...
  }
</pre>
	</div>
	<div class="title5">
	<h2><font size="6" color="#990012">Third Version of Word Count</font></h2>
		<p><font size="4" color="#3D3C3A">
		&nbsp;&nbsp;&nbsp;		
		Since lines in each worker may contains lots of same words, we can reduce the asking by init once:
		</font></p>
<pre class="prettyprint">
// wc.hpp
private:
  void local_learning(const vector<string> & lines) {
    
    // init once
    unordered_map<string, int> tmp;
    for(auto & line : lines) {
      auto word_lst = local_parser(line);
      for(auto & word : word_lst) {
        tmp[word] = 0;
      }
    }
    paracel_write_multi(tmp);
    sync();
    
    for(auto & line : lines) {
      auto word_lst = local_parse(line);
      for(auto & word : word_lst) {
        paracel_bupdate(word, 1);
      }
    }
    ...
}
</pre>
	<p><font size="4" color="#3D3C3A">
	&nbsp;&nbsp;&nbsp;		
	What's more, you can still do some optimization according to your application. For example, do some local combine to minimize the commnunication. But we will stop here.
	</font></p>
	</div>
	<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js?lang=css&skin=sunburst"></script>
</body>
</html>