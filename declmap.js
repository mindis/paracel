var declmap = {
};
var docs = {
	"overview": {
		"name": "overview",
		"title": "overview",
		"content": "# Paracel\n\nParacel is a distributed computational framework designed for machine learning problems, graph algorithms and scientific computation in C++\n\n## Motivation\n\n * Parameters can not be hold in memory of one node\n\n * Asynchrounous learning to speed up convergency\n\n * General framework\n  - Simple communication model(compared to MapReduce)\n\n  - Fault tolerance solution(compared to MPI)\n\nOur basic idea is triggered by Jeff Dean's [talk](http://infolab.stanford.edu/infoseminar/dean.pdf) @Stanford University in 2013.\nYou can get more details in his paper: [Large Scale Distributed Deep Networks](http://static.googleusercontent.com/media/research.google.com/en//archive/large_deep_networks_nips2012.pdf)\n\n## Goals\n\n * Split both massive dataset and massive parameter space.\n\n * Solve \"the last reducer problem\" of iterative tasks.\n\n * Easy to programming, painless from serial to parallel.\n\n * Good performance and fault tolerant.\n\n## Downloading\n\nYou can get the source code from http://code.dapps.douban.com/paracel:\n\n```bash\n$ git clone http://code.dapps.douban.com/paracel.git\n```\n\n## Installation\n\n * I.**Prerequisite**\n\n You must firstly install some external libraries below:\n\n  - [Boost(>=1.54)](http://www.boost.org/)\n\n  - Zeromq(>=3.2.4) and [a c++ binding](http://zeromq.org/bindings:cpp) of it\n\n  - [Msgpack-c-0.5.8](https://github.com/xunzhang/msgpack-c): a increment version\n\n  - [Eigen(>=3.0)](http://eigen.tuxfamily.org/)\n\n  - [GFlags](https://code.google.com/p/gflags/)\n\n And make sure you have:\n\n  - a impl version of MPI\n\n  - `gcc-4.`/`g++-4.7` or higher\n\n  - `autotools`\n\n *  II.**Build**\n\n```bash\n$ mkdir build; cd build;\n$ cmake -DCMAKE_BUILD_TYPE=Release ..\n$ make -j 4\n$ make install\n```\n\nIf you use gentoo, you can just use ebuild files we provide\n\nStuff @[Douban.Inc](http://www.douban.com/) can just skip **phaseI**\n\n## Get started\n\nA 20-minutes' tutorial is [here](quickstart.html)\n\n## Contact \n\nYou are welcome to join this [group](https://groups.google.com/forum/#!forum/paracel). And if you are using paracel, let me know.\n\nAny bugs and related problems, feel free to ping me: <wuhong@douban.com>, <xunzhangthu@gmail.com>.\n\n## License\n\nParacel is made avaliable under the terms of the BSD License. See the LICENSE file that accompanies this distribution for the full text.",
		"decl_titles": []
    },
    "paralg": {
    		"name": "paralg",
    		"title": "paralg",
		"codename": "ps",
    		"content": "\n# Paralg\n\nThe main public interfaces are defined in the baseclass named `paralg`.\n\n\n## Initialize\n\n```c++\nparalg(paracel::Comm comm, paracel::str_type _output, int _rounds);\n```\n\n\n*Constructor*\n\n\nDirectly use to initializate.\n\n`comm` is the communication channel, `_output` is the output folder to dump results, `_rounds` is the rounds to traverse the dataset.\n\n```c++\nparalg(paracel::str_type hosts_dct_str,\n  paracel::Comm comm,\n  paracel::str_type _output,\n  int _rounds = 1,\n  int _limit_s = 0,\n  bool _ssp_switch = false);\n```\n\n\n*Constructor*\n\n\nNormal constructor. `_rounds`, `_limit_s` and `_ssp_switch` are used for ssp controlling in iterative tasks which can be set by default.\n\n## loading\n\nWhile loading data, paracel will split dataset into many slices, each worker fetch these slices until the end. To make sure thar each worker get desirable data, we define two variables: `pattern` and `mix_flag`.\n\n`pattern` defines the data format below:\n\n<table border=\"2\"><tbody><tr><td><em>pattern</em></td><td><em>format</em></td><td><em>description</em></td></tr><tr><td>linesplit(default)</td><td>load with lines, no partition</td><td>every case</td></tr><tr><td>fmap</td><td>fsv case, partition by first field</td><td>['a','b'] or ['a','b:0.2']</td></tr><tr><td>smap</td><td>sfv case, partition by second field</td><td>['a','b'] or ['a','b:0.2']</td></tr><tr><td>fsmap</td><td>2D partition</td><td>['a','b'] or ['a','b:0.2']</td></tr><tr><td>fset</td><td>partition by first field</td><td>['a','b','c'] or ['a','b|0.2','c|0.4'].['a','0.2','0.4'] not supported</td></tr></tbody></table>\n\n`mix_flag` together with `pattern` to help define the partition method. See examples below:\n\n<table border=\"2\"><tbody><tr><td><em>mix_flag</em></td><td><em>example</em></td></tr><tr><td>true</td><td>'a,b,c,d\\n'</td></tr><tr><td>true</td><td>'a,b\\na,c,d\\n'</td></tr><tr><td>false(default)</td><td>'a,b\\na,c\\na,d\\n'</td></tr></tbody></table>\n\n\nYou can see here, `pattern` not only decide data format but also decide partition strategy while `mix_flag` tell if a relationship is mixed in a single line.\n\n### paracel_loadall\n\n```c++\nparacel::list_type<paracel::str_type> paracel_loadall(const T & fn);\n```\n\n\n*load all lines*\n\n\n### paracel_sequential_loadall\n\n```c++\nvoid paracel_sequential_loadall(const T & fn, F & func);\n```\n\n\n*load all lines and call func at the same time*\n\n\n### paracel_load\n\n```c++\nparacel::list_type<paracel::str_type> paracel_load(const T & fn,\n  parser_type & parser,\n  const paracel::str_type & pattern = \"linesplit\",\n  bool mix_flag = false);\n```\n\n\n*load fn with pattern and mix_flag*\n\n\n```c++\nparacel::list_type<paracel::str_type> paracel_load(const T & fn,\n  const paracel::str_type & pattern = \"linesplit\",\n  bool mix_flag = false);\n```\n\n\n*load fn using parser together with pattern and mix_flag*\n\n\nWhen you are using specified pattern and mix_flag, parser parameter can be omitted.\n\n### paracel_load_as_graph\n\n```c++\nvoid paracel_load_as_graph(paracel::bigraph<> & grp,\n  paracel::dict_type<size_t, int> & degree_map,\n  paracel::dict_type<size_t, int> & col_degree_map,\n  const T & fn,\n  parser_type & parser,\n  const paracel::str_type & pattern = \"fmap\",\n  bool mix_flag = false);\n```\n\n\n*load fn using parser, pattern, mix_flag then create a bigraph(with degree_map and col_degree_map)*\n\n\n```c++\nvoid paracel_load_as_graph(paracel::bigraph<> & grp,\n  const T & fn,\n  parser_type & parser,\n  const paracel::str_type & pattern = \"fmap\",\n  bool mix_flag = false);\n```\n\n\n*load fn using parser, pattern, mix_flag then create a bigraph*\n\n\n### paracel_load_as_matrix\n\n```c++\nvoid paracel_load_as_matrix(Eigen::SparseMatrix<double, Eigen::RowMajor> & blk_mtx,\n  paracel::dict_type<size_t, paracel::str_type> & row_map,\n  paracel::dict_type<size_t, paracel::str_type> & col_map,\n  paracel::dict_type<size_t, int> & degree_map,\n  paracel::dict_type<size_t, int> & col_degree_map,\n  const T & fn,\n  parser_type & parser,\n  const paracel::str_type & pattern = \"fsmap\",\n  bool mix_flag = false);\n```\n\n\n*load fn using parser, pattern, mix_flag then create sparse matrix(with row_map, col_map, degree_map, col_degree_map)*\n\n\n```c++\nvoid paracel_load_as_matrix(Eigen::SparseMatrix<double, Eigen::RowMajor> & blk_mtx,\n  paracel::dict_type<size_t, paracel::str_type> & row_map,\n  paracel::dict_type<size_t, paracel::str_type> & col_map,\n  const T & fn,\n  parser_type & parser,\n  const paracel::str_type & pattern = \"fsmap\",\n  bool mix_flag = false);\n```\n\n\n*load fn using parser, pattern, mix_flag then create sparse matrix(with row_map, col_map)*\n\n\n```c++\nvoid paracel_load_as_matrix(Eigen::SparseMatrix<double, Eigen::RowMajor> & blk_mtx,\n  const T & fn,\n  parser_type & parser,\n  const paracel::str_type & pattern = \"fsmap\",\n  bool mix_flag = false);\n```\n\n\n*load fn using parser, pattern, mix_flag then create sparse matrix*\n\n\n```c++\nvoid paracel_load_as_matrix(Eigen::MatrixXd & blk_dense_mtx,\n  paracel::dict_type<size_t, paracel::str_type> & row_map,\n  const T & fn,\n  parser_type & parser,\n  const paracel::str_type & pattern = \"fsmap\",\n  bool mix_flag = false);\n```\n\n\n*load fn using parser, pattern, mix_flag then create dense mastrix(with row_map)*\n\n\n```c++\nvoid paracel_load_as_matrix(Eigen::MatrixXd & blk_dense_mtx,\n  const T & fn,\n  parser_type & parser,\n  const paracel::str_type & pattern = \"fsmap\",\n  bool mix_flag = false);\n```\n\n\n*load fn using parser, pattern, mix_flag then create dense mastrix*\n\n\n## Communication\n\nCommunication in paracel is simple and flexible.\n\n### paracel_read\n\n```c++\nbool paracel_read(const paracel::str_type & key, V & val, int replica_id = -1);\n```\n\n\n*read to val with specified key*\n\n\n```c++\nV paracel_read(const paracel::str_type & key, int replica_id = -1)\n```\n\n\n*read specified key, return the value*\n\n\nYou can just ignore the `replica_id` parameter.\n\n### paracel_readall\n\n```c++\nparacel::dict_type<paracel::str_type, V> paracel_readall();\n```\n\n\n*read all key-value pairs to a dict*\n\n\n### paracel_read_topk\n\n```c++\nvoid paracel_read_topk(int k,\n  paracel::list_type<std::pair<paracel::str_type, int> > & result);\n```\n\n\n*read topk value into a list*\n\n\nBy default, this function will sort by value and now only works for `int` value.\n\n### paracel_write\n\n```c++\nbool paracel_write(const paracel::str_type & key, const V & val, bool replica_flag = true);\n```\n\n\n*write key with specified value*\n\n\n### paracel_write_multi\n\n```c++\nbool paracel_write_multi(const paracel::dict_type<paracel::str_type, V> & dct);\n```\n\n\n*write multi keys*\n\n\n### paracel_register_update\n\n```c++\nbool paracel_register_update(const paracel::str_type & file_name, const paracel::str_type & func_name);\n```\n\n\n*register update function with specified file_name and func_name*\n\n\n### paracel_update\n\n```c++\nvoid paracel_update(const paracel::str_type & key, const V & delta, bool replica_flag = true);\n```\n\n\n*update key's value with delta*\n\n\nNotice that this interface is non-block.\n\n### paracel_register_bupdate\n\n```c++\nbool paracel_register_bupdate(const paracel::str_type & file_name, const paracel::str_type & func_name);\n```\n\n\n*register bupdate function with specified file_name and func_name*\n\n\n### paracel_bupdate\n\n```c++\nvoid paracel_bupdate(const paracel::str_type & key, const V & delta, bool replica_flag = true)\n```\n\n\n*update key's value with delta(block)*\n\n\n```c++\nvoid paracel_bupdate(const paracel::str_type & key,\n  const V & delta,\n  const paracel::str_type & file_name,\n  const paracel::str_type & func_name,\n  bool replica_flag = true);\n```\n\n\n*update key's value with delta(block) using specified file_name and func_name*\n\n\nIf you use register interface, no need to specify file_name and func_name each time. But when you use different update rules, you need to use this interface.\n\n### paracel_update_default\n\n```c++\nvoid paracel_update_default(const paracel::str_type & key, const V & v_or_delta);\n```\n\n\n*similar to setdefault in Python*\n\n\nIf key does not exist, set its value with v_or_delta. Otherwise, update its value with v_or_delta.\n\n### paracel_contains\n\n```c++\nbool paracel_contains(const paracel::str_type & key);\n```\n\n\n*check if key is existed*\n\n\n### set_decomp_info\n\n```c++\nvoid set_decomp_info(const paracel::str_type & pattern);\n```\n\n\n*set decomposition infomation*\n\n\n### get_decomp_info\n\n```\nvoid get_decomp_info(int & x, int & y);\n```\n\n\n*get decomposition infomation from x and y*\n\n\n### get_worker_id\n\n```c++\nint get_worker_id();\n```\n\n\n*get worker id*\n\n\n### get_worker_size\n\n```c++\nint get_worker_size();\n```\n\n\n*get worker number*\n\n\n### sync\n\n```c++\nvoid sync();\n```\n\n\n*block until all processes have reached here*\n\n\n### get_comm\n\n```c++\nparacel::Comm get_comm();\n```\n\n\n*get workers' communication channel*\n\n\n## Asynchronous Controlling\n\nParacel use Stale Synchronous Parallel(SSP) to control the asynchronous learning [which](http://reports-archive.adm.cs.cmu.edu/anon/ml2013/CMU-ML-13-103.pdf) is prove to be correct and effective. You need to use the following SSP interfaces when facing iterative machine learning tasks.\n\n### iter_commit\n\n```c++\nvoid iter_commit();\n```\n\n\n*commit to servers after one epoch*\n\n\n### set_total_iters\n\n```c++\nvoid set_total_iters(int n);\n```\n\n\n*set total number of epoches*\n\n\nYou must use this interface to initialize the number of epoch.\n\n### is_cached\n\n```c++\nbool is_cached(const paracel::str_type & key);\n```\n\n\n*check whether the key is cached locally*\n\n\n### get_cache\n\n```c++\nV get_cache(const paracel::str_type & key);\n```\n\n\n*get cached key's value*\n\n\n",
    		"decl_titles": [
    		],
		"raw_content": "..."
    },
    "graph": {
    		"name": "graph",
    		"title": "graph",
		"codename": "graph",
    		"content": "\n# Graph\n\nParacel defines two types of graph:\n\n * bigraph(default)\n * undirected_graph\n\nWe will give the interface of bigraph and undirected_graph is similar.\n\nIn the mathematical field of graph theory, a bipartite graph (or bigraph) is a graph whose vertices can be divided into two disjoint sets U and V (that is, U and V are each independent sets) such that every edge connects a vertex in U to one in V.\n\n### add_edge\n\n```c++\nadd_edge(const T & v, const T & w);\n```\n\n\n*Add a link between vertex v and vertex w*\n\n\n```c++\nvoid add_edge(const T & v, const T & w, double wgt);\n```\n\n\n*Add a link between vertex v and vertex w with weight wgt*\n\n\nThis interface is also used for construct a bigraph internally.\n\n### traverse\n\n```c++\nvoid traverse(F & func);\n```\n\n\n*Traverse the graph with func*\n\n\n```c++\nvoid traverse(const T & v, F & func);\n```\n\n\n*Traverse edges linked with vertex v with func.*\n\n\n`Func` must take (v, w, wgt) as its three parameters.\n\n### dump2triples\n\n```c++\nvoid dump2triples(paracel::list_type&lt;std::tuple&lt;T, T, double\> \> & tpls);\n```\n\n\n*Dump graph into a list of triples: `tpls`*\n\n\n### dump2dict\n\n```c++\nvoid dump2dict(paracel::dict_type&lt;T, paracel::dict_type&lt;T, double\> \> & dict);\n```\n\n\n*Dump graph into a dict: `dict`*\n\n\n### reverse\n\n```c++\nbigraph reverse();\n```\n\n\n*Reverse the direction of every edge*\n\n\n### adjacent\n\n```c++\nparacel::dict_type&lt;T, double\> adjacent(const T & v);\n```\n\n\n*Get the adjacent of vertex v.*\n\n\n### out-degree\n\n```c++\nsize_t outdegree(const T & v);\n```\n\n\n*Return the out degree of vertex v.*\n\n\n### in-degree\n\n```c++\nsize_t indegree(const T & v);\n```\n\n\n*Return the in degree of vertex v.*\n\n\n### avg_degree\n\n```c++\ndouble avg_degree();\n```\n\n\n*Return the average of degrees.*\n\n\n### self-loops\n\n```c++\nint selfloops();\n```\n\n\n*Return number of self-loops of the graph.*\n\n\n",
    		"decl_titles": [
    		],
    		"raw_content": "..."
    },
    "prun": {
		"name": "prun",
		"title": "prun",
		"codename": "prun.py",
		"content": "\n# prun\n\nSubmit a batch job to the cluster.\n\n```bash\nUsage: prun.py [options]\n\nOptions:\n -h, --help\t show this help message and exit\n -p PARASRV_NUM, --snum=PARASRV_NUM\n\t\t\t\tnumber of parameter servers\n -w WORKER_NUM, --wnum=WORKER_NUM\n\t\t\t\tnumber of workers for learning\n -c CONFIG, --cfg_file=CONFIG\n\t\t\t\tconfig file in json fmt, for alg usage\n -m local | mesos | mpi, --method=local | mesos | mpi\n\t\t\t\trunning method\n --ppn=PPN\t  procs number per node - mesos\n --mem_limit=MEM_LIMIT\n\t\t\t\tmemory size of each task - mesos\n --hostfile=HOSTFILE\n\t\t\t\thostfile for mpirun - mpi\n```\n\nParacel supports three kinds of runtime environment(`-m`):\n\n * local machine\n\n * mesos cluster\n\n * mpi cluster\n\n## local\n\nRunning the program locally with option `-m local`.\n\n## mesos \n\nRuning the program in mesos cluster with option `-m mesos`.\n\nIn this case, you can also specify options: `--ppn` and `--mem_limit`. See help for more detail.\n\n## mpi \n\nRunning the program in mpi cluster with option `-m mpi`.\n\nHere you must specify hostfile with option `--hostfile`.",
		"decl_titles" : [
		],
		"raw_content": "..."
    },
    "utility": {
		"name": "utility",
		"title": "utility",
		"codename": "utils",
		"content": "\n# Utility\n\nSome utilities may be useful.\n\n## Json parser\n\n```json\n// cfg.json\n{\n\"input\": \"/home/feifei/input/*.csv\",\n\"ktop\": 10\n}\n```\n```c++\n\#include &lt;string>\n\#include \"utils.hpp\"\nparacel::json_parser jp(\"cfg.json\")\nstring input = jp.parse<string>(\"input\");\nint k = jp.parse<int>(\"ktop\");```\n\n## String operation\n\n```c++\nparacel::list_type<paracel::str_type> str_split(const paracel::str_type & str,\n  const paracel::str_type & seps);\n```\n\n\n*split string that matches any of the characters specified in seps*\n\n\n```c++\nparacel::list_type<paracel::str_type> str_split_by_word(const paracel::str_type & str,\n  const paracel::str_type & seps);\n```\n\n\n*split string that matches seps(as a word)*\n\n\n```c++\nbool startswith(const paracel::str_type & str, const paracel::str_type & key);\n```\n\n\n*return true if str starts with the specified prefix key, false otherwise.*\n\n\n```c++\nbool endswith(const paracel::str_type & str, const std::string & key);\n```\n\n\n*return true if str ends with the specified prefix key, false otherwise.*\n\n\n## plog\n\n...",
		"decl_titles" : [
		],
		"raw_content": "..."
    },
    "updater": {
		"name": "updater",
		"title": "updater",
		"codename": "proxy",
		"content": "\n#Update Function\n\nYou can write any update function required by your application.\n\nFor example:\n\n```c++\nint update(int a, int b) {\n  return a + b;\n}\n```\n\nThe first parameter of the update function is value, the second parameter of the update function is delta. Here we update value with adding delta. Notice that value type and delta type must be the same.\n\n```c++\n\#include \"proxy.hpp\"\n\nparacel::update_result updater = paracel::update_proxy(update);\n\nextern \"C\" {\n  extern paracel::update_result updater;\n}\n```\n\nThen you need to register your `update` function into <b>paracel</b>. You can see more examples inside `alg` folder.",
		"decl_titles" : [
		],
		"raw_content": "..."
    },
    "recovery": {
		"name": "recovery",
		"title": "recovery",
		"codename": "recovery",
		"content": "\n# Fault Recovery\n\nTODO\n\n",
		"decl_titles" : [
		],
		"raw_content": "..."
    },
};
